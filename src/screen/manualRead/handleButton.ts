import { hookProps, store } from './controller';
import { Alert, EventSubscription, PermissionsAndroid, Platform } from 'react-native';
import Geolocation from '@react-native-community/geolocation';
import { getDistanceValue } from '../../util/location';
import { buildQueryDataPacket } from '../../service/hhu/aps/hhuAps';
import { checkPeripheralConnection, send } from '../../util/ble';
import { parseDate, parseUint16, parseUint32 } from '../../util';
import { changeMeterStatus, insertMeterData, insertMeterHistoryBatch } from '../../database/repository';
import BleManager from 'react-native-ble-manager';
let hhuReceiveDataListener: EventSubscription | null = null;
// ‚úÖ Xin quy·ªÅn v·ªã tr√≠
let watchId: number | null = null;

export const requestLocationPermission = async () => {
  try {
    // ‚úÖ B·∫≠t loading tr∆∞·ªõc khi xin quy·ªÅn
    hookProps.setState((prev) => ({
      ...prev,
      isLoading: true,
      textLoading: 'ƒêang xin quy·ªÅn truy c·∫≠p v·ªã tr√≠...',
    }));

    if (Platform.OS === 'android') {
      const granted = await PermissionsAndroid.request(
        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
        {
          title: 'Quy·ªÅn truy c·∫≠p v·ªã tr√≠',
          message: '·ª®ng d·ª•ng c·∫ßn truy c·∫≠p v·ªã tr√≠ ƒë·ªÉ ho·∫°t ƒë·ªông ch√≠nh x√°c.',
          buttonPositive: 'ƒê·ªìng √Ω',
          buttonNegative: 'H·ªßy',
        }
      );

      if (granted !== PermissionsAndroid.RESULTS.GRANTED) {
        console.log('‚ùå Quy·ªÅn truy c·∫≠p v·ªã tr√≠ b·ªã t·ª´ ch·ªëi');
        hookProps.setState((prev) => ({
          ...prev,
          isLoading: false,
          textLoading: 'B·∫°n ƒë√£ t·ª´ ch·ªëi quy·ªÅn v·ªã tr√≠',
          currentLocation: [],
        }));
        clearLocationWatch();
        return;
      }
    }

    // ‚úÖ ƒê∆∞·ª£c c·∫•p quy·ªÅn ‚Üí b·∫Øt ƒë·∫ßu theo d√µi v·ªã tr√≠
    startWatchingPosition();
  } catch (err) {
    console.error('‚ùå L·ªói xin quy·ªÅn v·ªã tr√≠:', err);
    hookProps.setState((prev) => ({
      ...prev,
      isLoading: false,
      textLoading: 'L·ªói khi xin quy·ªÅn v·ªã tr√≠',
    }));
    clearLocationWatch();
  }
};

export const startWatchingPosition = () => {
  clearLocationWatch(); // Clear watch c≈© n·∫øu c√≥

  // L·∫•y v·ªã tr√≠ ban ƒë·∫ßu
  Geolocation.getCurrentPosition(
    (pos) => {
      const { latitude, longitude } = pos.coords;
      if (!isNaN(latitude) && !isNaN(longitude)) {
        hookProps.setState((prev) => ({
          ...prev,
          currentLocation: [longitude, latitude],
          isLoading: false,
          textLoading: '',
        }));
      }
    },
    (err) => {
      console.log('‚ùå L·ªói l·∫•y v·ªã tr√≠ ban ƒë·∫ßu:', err);
      hookProps.setState((prev) => ({
        ...prev,
        isLoading: false,
        textLoading:
          'Kh√¥ng l·∫•y ƒë∆∞·ª£c v·ªã tr√≠. H√£y b·∫≠t GPS ho·∫∑c di chuy·ªÉn ra ngo√†i tr·ªùi',
      }));
    },
    { enableHighAccuracy: true, timeout: 8000, maximumAge: 0 }
  );

  // B·∫Øt ƒë·∫ßu theo d√µi li√™n t·ª•c
  watchId = Geolocation.watchPosition(
    (pos) => {
      const { latitude, longitude } = pos.coords;
  
      if (!isNaN(latitude) && !isNaN(longitude)) {
        hookProps.setState((prev) => ({
          ...prev,
          currentLocation: [longitude, latitude],
        }));
      }
    },
    (err) => console.log('‚ùå L·ªói c·∫≠p nh·∫≠t v·ªã tr√≠:', err),
    {
      enableHighAccuracy: true,
      distanceFilter: 5, // ch·ªâ c·∫≠p nh·∫≠t khi di chuy·ªÉn >= 5m
      interval: 1000, // update m·ªói 1s
      fastestInterval: 1000,
      maximumAge: 1000,
    }
  );
  
};

export const clearLocationWatch = () => {
  if (watchId !== null) {
    Geolocation.clearWatch(watchId);
    watchId = null;
  }
};

export const stopReading = () => {
  shouldStopReading = true;
  hookProps.setState((prev) => ({ ...prev, isAutoReading: false }));
  console.log("üõë ƒê√£ y√™u c·∫ßu d·ª´ng ƒë·ªçc meter");
};
let shouldStopReading = false;

// Bi·∫øn l∆∞u serial meter ƒëang ƒë·ªçc hi·ªán t·∫°i
let currentMeterSerialReading: string | null = null;

export const readMetersOnce = async () => {
  shouldStopReading = false;

  const isConnected = await checkPeripheralConnection(store.state.hhu.idConnected);
  if (!isConnected) return;

  hookProps.setState(prev => ({ ...prev, isAutoReading: true }));

  const currentLocation = hookProps.state.currentLocation;
  if (!currentLocation) {
    hookProps.setState(prev => ({ ...prev, isAutoReading: false }));
    return;
  }

  const distanceLimit = Number(store.state.appSetting.setting.distance);

  const metersToRead = hookProps.state.listMeter
    .filter(meter => meter.COORDINATE && ["0","2","6"].includes(meter.STATUS) && getDistanceValue(meter.COORDINATE, currentLocation) <= distanceLimit)
    .sort((a, b) => getDistanceValue(a.COORDINATE, currentLocation) - getDistanceValue(b.COORDINATE, currentLocation));

  if (metersToRead.length === 0) {
    hookProps.setState(prev => ({ ...prev, isAutoReading: false }));
    return;
  }

  for (const meter of metersToRead) {
    if (shouldStopReading) break;

    console.log(`üîÑ ƒêang ƒë·ªçc meter: ${meter.METER_NO}`);

    // ‚úÖ C·∫≠p nh·∫≠t readingStatus: "reading"
    hookProps.setState(prev => ({
      ...prev,
      readingStatus: {
        meterNo: meter.METER_NO,
        name: meter.CUSTOMER_NAME,
        status: "reading",
      },
      listMeter: prev.listMeter.map(m => m.METER_NO === meter.METER_NO ? { ...m, STATUS: "6" } : m)
    }));
    await changeMeterStatus(meter.METER_NO, "6");

    // Build g√≥i d·ªØ li·ªáu v√† g·ª≠i
    const dataPacket = buildQueryDataPacket(meter.METER_NO);
    await send(store.state.hhu.idConnected, dataPacket);

    currentMeterSerialReading = meter.METER_NO;

    // Promise ch·ªù d·ªØ li·ªáu t·ª´ meter ƒë√∫ng serial
    await new Promise<void>((resolve) => {
      let timeout: NodeJS.Timeout;

      const listener = BleManager.onDidUpdateValueForCharacteristic(async (data: { value: number[] }) => {
        const buf = Buffer.from(data.value);
        if (buf.length < 15) return;

        const meterSerialBytes = buf.slice(4, 14);
        const serialReceived = meterSerialBytes.toString("ascii");
        if (serialReceived !== currentMeterSerialReading) return;

        // Nh·∫≠n ƒë√∫ng meter ‚Üí x·ª≠ l√Ω d·ªØ li·ªáu
        const payload = Array.from(buf.slice(14, 14 + buf[3]));
        const success = await responeData(payload, serialReceived);

        hookProps.setState(prev => ({
          ...prev,
          readingStatus: {
            meterNo: meter.METER_NO,
            name: meter.CUSTOMER_NAME,
            status: success ? "success" : "fail",
          },
          listMeter: prev.listMeter.map(m =>
            m.METER_NO === meter.METER_NO ? { ...m, STATUS: success ? "1" : "2" } : m
          ),
        }));
        changeMeterStatus(meter.METER_NO, success ? "1" : "2");
        clearTimeout(timeout);
        listener.remove();

        // ‚è≥ ƒê·ª£i 1s cho ng∆∞·ªùi d√πng nh√¨n th·∫•y tr·∫°ng th√°i th√†nh c√¥ng/th·∫•t b·∫°i
        setTimeout(resolve, 1000);
      });

      timeout = setTimeout(() => {
        console.warn(`‚è± Timeout meter ${meter.METER_NO}`);
        hookProps.setState(prev => ({
          ...prev,
          readingStatus: {
            meterNo: meter.METER_NO,
            name: meter.CUSTOMER_NAME,
            status: "fail",
          },
          listMeter: prev.listMeter.map(m =>
            m.METER_NO === meter.METER_NO ? { ...m, STATUS: "2" } : m
          ),
        }));
        changeMeterStatus(meter.METER_NO, "2");
        listener.remove();

        setTimeout(resolve, 1000);
      }, 5000);
    });

    currentMeterSerialReading = null;
    await new Promise(res => setTimeout(res, 200));
  }

  hookProps.setState(prev => ({
    ...prev,
    isAutoReading: false,
    readingStatus: null, // ‚úÖ ·∫©n thanh khi xong
  }));

  console.log("‚úÖ ƒê·ªçc xong ho·∫∑c ƒë√£ d·ª´ng ƒë·ªçc");
};


export let hhuHandleReceiveData = (data: { value: number[] }) => {
  const buf = Buffer.from(data.value);

  if (buf.length >= 15 && buf[0] === 0x02 && buf[1] === 0x08) {
    const commandType = buf[2];
    const lenPayload = buf[3];
    const meterSerial = buf.slice(4, 14).toString("ascii");

    // Ch·ªâ x·ª≠ l√Ω meter ƒëang ƒë·ªçc
    if (meterSerial !== currentMeterSerialReading) return;

    const payload = Array.from(buf.slice(14, 14 + lenPayload));

    switch (commandType) {
      case 0x01:
        responeData(payload, meterSerial);
        break;
      default:
        console.log("‚ö†Ô∏è Unknown commandType:", commandType);
    }
  }
};

export async function responeData(payload: number[], meterSerial: string): Promise<boolean> {
  if (payload.length < 3) {
    console.warn("‚ö†Ô∏è Payload qu√° ng·∫Øn:", payload);
    return false;
  }

  const u8CommandCode = payload[0];
  const indexPacket = payload[1];
  const recordCount = payload[2];
  console.log(`üì• Nh·∫≠n g√≥i index=${indexPacket}, recordCount=${recordCount}, cmd=${u8CommandCode}`);

  const bytePerRecord = u8CommandCode === 1 ? 4 : 2;
  let offset = 3;

  let currentTime = "";
  let impData = 0;
  let expData = 0;
  let event = "";
  let batteryLevel = "";
  let latchPeriodMinutes = 0;

  if (indexPacket === 1) {
    currentTime = parseDate(payload.slice(offset, offset + 6));
    offset += 6;

    impData = parseUint32(payload.slice(offset, offset + 4));
    offset += 4;

    expData = parseUint32(payload.slice(offset, offset + 4));
    offset += 4;

    event = payload[offset].toString(16).padStart(2, "0");
    offset += 1;

    const voltage = payload[offset] / 10;
    batteryLevel = `${Math.min(100, Math.max(0, (voltage / 3.6) * 100)).toFixed(0)}%`;
    offset += 1;

    latchPeriodMinutes = (payload[offset] & 0xff) | ((payload[offset + 1] & 0xff) << 8);
    offset += 2;
  }

  // ‚úÖ X√°c ƒë·ªãnh baseTime
  let baseTime: Date;
  if (indexPacket === 1) {
    baseTime = new Date(currentTime);
    if (isNaN(baseTime.getTime())) baseTime = new Date();
  } else {
    baseTime = new Date();
  }

  const records: { timestamp: string; value: number }[] = [];
  const historyBatch: { METER_NO: string; TIMESTAMP: string; DATA_RECORD: string }[] = [];
  let insertedCount = 0;

  for (let i = 0; i < recordCount; i++) {
    const start = offset + i * bytePerRecord;
    const valueBytes = payload.slice(start, start + bytePerRecord);
    const value = u8CommandCode === 1 ? parseUint32(valueBytes) : parseUint16(valueBytes);

    const recordTime = new Date(baseTime);
    recordTime.setMinutes(recordTime.getMinutes() - i * latchPeriodMinutes);

    if (isNaN(recordTime.getTime()) || recordTime.getFullYear() < 2000 || recordTime.getFullYear() > 2100) {
      console.warn(`‚õî recordTime kh√¥ng h·ª£p l·ªá, b·ªè qua`, recordTime);
      continue;
    }

    const timestamp = recordTime.toISOString();
    console.log(`üìä [G√≥i ${indexPacket}] Record ${i + 1}/${recordCount} ‚Üí ${timestamp} (Value=${value})`);

    records.push({ timestamp, value });

    // ‚úÖ Gom d·ªØ li·ªáu v√†o batch history
    historyBatch.push({
      METER_NO: meterSerial,
      TIMESTAMP: timestamp,
      DATA_RECORD: value.toString(),
    });

    // ‚úÖ Ch·ªâ insert v√†o b·∫£ng METER_DATA v·ªõi b·∫£n ghi ƒë·∫ßu ti√™n (b·∫£n m·ªõi nh·∫•t)
    if (i === 0) {
      const ok = await insertMeterData({
        METER_NO: meterSerial,
        TIMESTAMP: timestamp,
        IMPORT_DATA: u8CommandCode === 1 ? value.toString() : "0",
        EXPORT_DATA: "0",
        EVENT: event,
        BATTERY: batteryLevel,
        PERIOD: latchPeriodMinutes.toString(),
      });

      if (ok) insertedCount++;
    }
  }

  // ‚úÖ Batch insert v√†o b·∫£ng l·ªãch s·ª≠ (Nhanh h∆°n g·ªçi t·ª´ng l·∫ßn)
  if (historyBatch.length > 0) {
    await insertMeterHistoryBatch(historyBatch);
  }

  // ‚úÖ Update state
  if (records.length > 0) {
    hookProps.setState((prev) => {
      const prevMeterData = prev.meterData;

      const sortedRecords = [...records].sort(
        (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
      );

      if (indexPacket === 1 || !prevMeterData || prevMeterData.serial !== meterSerial) {
        return {
          ...prev,
          meterData: {
            serial: meterSerial,
            currentTime,
            impData,
            expData,
            event,
            batteryLevel,
            latchPeriod: latchPeriodMinutes.toString(),
            dataRecords: sortedRecords,
          },
        };
      }

      const mergedRecords = [...prevMeterData.dataRecords, ...sortedRecords].sort(
        (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
      );

      return {
        ...prev,
        meterData: {
          ...prevMeterData,
          dataRecords: mergedRecords,
        },
      };
    });
  }

  return insertedCount > 0;
}


